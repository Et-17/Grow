# a phoneme is a bundle of arbitrary binary features
# internally, each hponeme stores a feature if it is positive or negative, and
# doesn't if it is unset
# this means that new features that get defined after the definition of a
# phoneme will be considered as unset
# the F command defines a new feature
F lateral
F voiced
F labial
F syllabic
F rounded
F stressed

# the S command is used for defining new feature sets.
# phonemes can only hold one of these features, and all others will be
# considered negative while matching.
# the application of any feature from the set via a plus in a phoneme
# definition will take the place of the preexisting feature.
# features in a feature set are refered to by `set.feature`.
# using a feature from a feature set in the negative will match every other
# feature from the set.
# feature sets are unset by using an empty feature name.
S type consonant vowel
S place bilabial dental alveolar post_alveolar palatal palatovelar velar pharyngeal
S manner nasal plosive fricative approximant tap trill
S height close near_close close_mid mid open_mid near_open open
S backness front near_front central near_back back
S length short long overlong

# definitions let us define shorthand ways to refer to phonemes
# these can be placed in bracket phoneme notation, which will base the 
# resulting phoneme off of the definition
D m [+consonant +place.bilabial +manner.nasal -lateral +voiced +short]
D n [+consonant +place.alveolar +manner.nasal -lateral +voiced +short]
D r [+consonant +place.alveolar +manner.trill -lateral +voiced +short]
D l [+consonant +place.alveolar +manner.approximant +lateral +voiced +short]
D u [+vowel +height.close +backness.back +rounded +syllabic +short]

# a language is a stage that can be evolved to or from.
# they must be defined using the L command before evolutions can be specified.
L exampleA
L exampleB

# an evolution from one language to another is defined by the application of
# evolution rules.
# you can specify these rule bundles by starting with the E command and ending
# with the C command.
# the first language is the start and the second is the result.
E exampleA exampleB

# rules are a group of target phonemes, a >, and then the output phonemes.
# when it matches the target phonemes, it will replace it with the output phonemes
# these rules desyllabize consonants by placing an epenthetic /u/ before them
R [m +syllabic] > u m
R [n +syllabic] > u n
R [r +syllabic] > u r
R [l +syllabic] > u l

# while brackets define a concrete phoneme which considers unset features to 
# be negative when matching, parenthesis define a feature matcher which will
# not take unset features into account.
# feature matchers may be prefixed with a number, in which case that number
# will be defined as the phoneme it matches in that rule's output.
# this rule also desyllabizes consonants by placing an epenthetic /u/ before them
R 1(+consonant +syllabic) > u [1 -syllabic]

# this rule merges the PIE palatovelar and velar plosives
R 1(+place.palatovelar +manner.plosive) > [1 +place.velar]

# rules can be followed by a backslash and then an environment descriptor.
# this is a group of phonemes or feature matchers, then an underscore denoting
# the target, and then another group of phonemes or feature matchers.
# you can also use # to represent the end or start of a word, ? to represent
# an arbitrary phoneme, and * to represent >=0 arbitrary phonemes
# this rule removes word-final non-high short vowels after a nasal
R (-height.high +length.short) > \ (+manner.nasal) _ #

# end the evolution rules from one language to another with the C command
C